//Бинарное дерево это частный случай дерева, где все элементы строго уникальны, каждый родитель имеет не более 2 детей,
//при этом левый ребенок всегда меньше родителя, а правй больше

//на бинарных деревьях эффективно выстраиваются поисковые алгоритмы
//алгоритм обхода бинарного дерева происходит в глубину и очень похож на бинарнй поиск,
// т к  каждый раз отсекается половина значени при выборе одного из узлов

//частный случай бинарного дерева, это балансированое дерево. для любого узла дерева высота
// его правого поддерева отличается от левого не более чем на еденицу
//это идеальная структура для бинарного поиска, потому что корень является стартовой позицией(мидл элемент)
//что дает сложность поиска по сбалансированному дереву логарифмическую

//в процессе добавления и удаления элементов для поддержания сбалансированности и соответственно сожности поиска,
// надо проводить операции балансировки

// их виды: красно-черное, авл дерево, 2,3 дерево

//авл дерево для балансировки хранит в ноде кроме значения и инфы о детях показатель глубины
//а красно черное дерево вместо глубины использует показатель цвета

public class BinaryTree<V extends Comparable<V>> {
    private Node root;

    private class Node {
        V value;
        Node left;
        Node right;
    }

    public boolean bypassInDepth(V value) {    // поиск в глубину на бинарном дереве логарифмически
        final Node node=bypassInDepth(value,root);
        return node!=null;
    }

   private Node  bypassInDepth(V value, Node node) {
        if (node.value.equals(value))
            return node;
        else {
            if (node.value.compareTo(value)>0){
                if (node.left!=null){
                    return bypassInDepth(value,node.left);
                }else return null;
            }else {
                if (node.right!=null){
                    return bypassInDepth(value, node.right);
                }else return null;
            }

        }
   }

}
