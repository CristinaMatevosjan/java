import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;

public class Main {

    public static final String FILE_NAME="table.csv";
    public static void main(String[] args) {
//Основа управления потоками ввода и вывода данных
// инпут_стрим и аутпут_стрим абстрактные классы (это родители все остальных классов )
// // , работают с байтами данных
// // для работы с символьными потоками есть ридер и врайтер
//
// InputStream someInputStream=null; //какой то условный поток ввода данных в программу
// int bytesCount= someInputStream.available(); //показывает сколько байтов данных можно считать из потока при работе с файлом,
// // в интернете коварен
// someInputStream.close(); //закрывает поток, чтобы не было утечек памяти

// int myByte=someInputStream.read();//считывает данные, есть несколько перегрузок,
// // первая,
// когда не принимает ничего на вход, тогда считывает 1 байт информации,
// т е придется реализовывать цикл, что не очень удобно
// // когда становится нечего читать(в файле/интернете)метод возвращает -1 EOF(энд оф файл)
//
// //следующая перегрузка:
//
// byte[] buffer=new byte[1024]; // буфер в который записываются данные из стрима,
// // 1024 на угад взято, предугадать нельзя
//
// someInputStream.read(buffer); // эта перегрузка метода принимает на вход массив байтовый,
// // когда будут записаны все данные из источника, метод вернет -1
//
// // Следующая перегрузка
//
// byte[] anotherBuffer=new byte[256];
// int bufferOfset=4;// куда в буфере будем класть данные(начиная с какой ячейки)
// int dataLength=200;//сколько мы хотим прочитать из источника
//
// someInputStream.read(anotherBuffer,bufferOfset,dataLength);
//
// //123456789
// //^
// int skiped=someInputStream.skip(3);// меняет положение указателя для начала
// // считывания потока, возвращает число лонг, значит сколько символов удалось пропустить
//
//
// //                Какие методы предоставляют наследники класса аутпутстрим
// OutputStream someOutputStream=null; // условный экземпляр класса для демонстрации методов
//
// someOutputStream.close();
//
// // этот класс для записи информации значит для этого есть метод врайт,
// // который тоже имеет несколько перегрузок
//
// int someByteInfo=1;
// someOutputStream.write(someByteInfo); // записывает 1 байт информации,принимает целое число аргументом
        //т е не надо приводить к байтам
//
// //такжу можно записывать гигабайты информации в виде байтового массива
// byte[] someData={1,2,3,4,5,6,7};
// someOutputStream.write(someData);//произойдет запись этого массива в какой то ресурс(файл или на удаленный сервер)
//
// // также можно начать запись с определенного индекса
// // и заканчивая, определенной длиной
//
// int someDataOfSet=3;
// int somedataLength=2;
// someOutputStream.write(someData,someDataOfSet,somedataLength); // первый аргумент массив
// // данных, второй отступ, третий длина
//
// someOutputStream.flush(); // принудительно пропихивает данные и очищает поток,
// // те хорошая практика после врайта вызывать флаш

//зачем это нужно? мы можем один и тот же объект в виде потока данных использовать для разных ресурсов,
//предположим есть 2 файла в один из которых захотели записать массив, вызвали врайт, затем переинициализировав поток вывода
//захотим записать что то другое, если предыдущая запись закончилась не полностью,
// остались байтовые массивы и тогда во второй файл полетит не то

//                           FileInputStream FileAutputStream

// это наследники предыдущих классов, значит и методы наследуют, работают с файлами

// файл_аутпут_стрим ( подразумевается вывод данных из программы в русурс) позволяет записывать набор данных в файл
// при работе с любым стримом надо использовать трай кеч

// try {
// FileOutputStream fileOutputStream=new FileOutputStream("hello.txt"); // этот конструктор принимает
// // либо путь к файлу, либо название файла с расширением и если его нет, создает его
//
//// FileOutputStream fileOutputStream1=new FileOutputStream("hello.txt",true); //эта перегрузка
//// // принимает еще флаг тру или фолс, означает
       // перезапись или добавление данных
//
// byte[] dataBytes="helloWorld!".getBytes(StandardCharsets.UTF_8); // этот метод переводит массив
// // в определенной кодировке в набор байтов
// fileOutputStream.write(dataBytes);
// fileOutputStream.close();
//
// }catch (Exception ex){
// System.out.println(ex.getMessage());
// }

//Но!!! при такой конструкции есть риск что поток все равно не закроется, лучше использовать следующее

// try - witch- resources
//        try (FileOutputStream fileOutputStream = new FileOutputStream("bye.txt", true)) { //здесь объявляется
//// переменная которая будет использоваться только в области видимости трай вив ресорса
//            byte[] dataBytes = "Bye-Bye!".getBytes(StandardCharsets.UTF_8);
//            fileOutputStream.write(dataBytes);
//        } catch (Exception ex) {
//            System.out.println(ex.getMessage()); // тогда метод клоз не нужен
//        }
//
//// FileInputStream считывание файлов в программу
////наследуется от инпутстрима значит реализует все его методы
//
//        try (FileInputStream fileInputStream = new FileInputStream("hello.txt")) { // не создает новых файлов!
//// в конструкторе указываем откуда читать, либо через путь,
//// либо имя ФАЙЛА ЕСЛИ ОН лежит в той же папке проекта
//            byte[] bytes = new byte[fileInputStream.available()]; //объявляем байтовый массив,
//// чтобы определить его длину используем метод авейлабл, который вернет
//// длину доступную для чтения данных
//            fileInputStream.read(bytes); // метод рид прочитает строку из файла и запишет ее в пустой массив байтов
//            System.out.println(new String(bytes)); // здесь используем конструктор строки который принимает на вход
//// байтовый массив и конвертирует его обратно в символы читаемые, выведем в консоль это
//        } catch (Exception ex) {
//            System.out.println(ex.getMessage());
//// но! это самый простой способ, его нельзя использовать
//// в сети интернет, потому что там чтение идет партиями и данные будут недостоверны
//        }
//
//// при чтении с удаленного сервера мы не знаем сколько данных можно считать
//
//        try (FileInputStream fileInputStream = new FileInputStream("hello.txt")) {
//            ArrayList<Byte> newData = new ArrayList<>(); // поэтому воспользуемся аррэй листом,
//// в который будем записывать набор данных
//
//            final int EOF = -1; // заводим константу конца данных,
//// те когда метод рид вернет -1, до этого момента продолжаем считывать байты
//
//            int tempBufer = 0; // переменная буфер, в которую циклом вайл,
//// будет записываться результат чтения из потока ввода методом рид пока не придет -1
//
//            while ((tempBufer = fileInputStream.read()) != EOF) {
//                newData.add((byte) tempBufer);
//
//            }
//// чтобы сделать это все человекочитаемо
//// ниже напишем свой метод для
//// конвертации из аррэй листа в байтовый массив, а здесь вызовем его
//
//            byte[] bytes = convertToBytes(newData);
//            System.out.println(new String(bytes)); //используем конструктор строки
//// чтобы создать из байтового массива читаемые символы
//
//
//        } catch (Exception ex) {
//            System.out.println(ex.getMessage());
//        }
//
//    }
//
//    public static byte[] convertToBytes(ArrayList<Byte> list) {
//        byte[] array = new byte[list.size()];
//
//        for (int i = 0; i < list.size(); i++) {
//            array[i] = list.get(i);
//        }
//        return array;


AppData appData=new AppData();
appData.newData();
appData.save(FILE_NAME);

appData.loading(FILE_NAME);






    }
}
//дз
//1.Реализовать сохранение данных в сиэсви файл
//2.Реализовать загрузку данных из сиэсви файла. файл читается целиком

//структура сиэс ви файла:
// строка заголовок с набором столбцов
//набор строк с целоцисленными значеними
//разделители это точки с запятой
//пример:
// валью 1;валью 2;валью3
//100;200;300
//400;500;600

//для хранения данных использовать класс вида:
//public class AppData{
// private String[] header;
// private int[][] data;
//


//Eсли выполняется save(AppData data) то данные в файле перезаписываются

// ....



